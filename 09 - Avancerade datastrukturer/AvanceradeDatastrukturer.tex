% The format (A5) is selected to facilitate reading on small
% devices and should NOT be changed. 
\documentclass[a5paper,10pt,oneside]{article}

% The package babel is loaded for Swdish with Swedish hyphenation,
% replaces "Contents" with "Innehållsförteckning, "References"
% with "Litteraturförteckning", etc.
\usepackage[swedish]{babel}

\usepackage[T1]{fontenc}

% The package "inputenc" lets us specify what character encoding
% has been used to save the .tex file. If your computer runs
% Linux, the encoding is probably "utf8" by default, while under
% Windows the default will probably be "latin1" The wrong
% character encoding may give strange signs instead of "å", "ä"
% and "ö" or may result in compilation errors.

%\usepackage[latin1]{inputenc} % Probably right if you use Windows
\usepackage[utf8]{inputenc}  % Probably right if you use Linux

% The packages listed below are optional and can be removed if you
% don't use them 
\usepackage{graphicx} 
\usepackage{cite}
\usepackage{url}
\usepackage{ifthen}
\usepackage{listings}	


% These two lines set up options for the listings package and
% can be removed if you don't use it, or changed if you, e.g, 
% use another language than Java. 
% For more information about the listings package see:
% ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\def \lstlistingname {Kodexempel}
\lstset{language=Java,tabsize=3,numbers=left,frame=L,floatplacement=hbtp}


\usepackage{ifpdf}
\ifpdf
	\usepackage[hidelinks]{hyperref}
\else
	\usepackage{url}
\fi


% Change NR and TITLE below to appropriate values
\title{Tema NR: 9 Avancerade datastrukturer}

% Write the name and user namn for all participants in the group here.
% Separate persons with \and
\author{Oscar Törnquist \url{osta3589} \and Emil Rosell \url{emro9957}}



\begin{document}
\maketitle

\section*{Treaps}

En treap är en slumpmässig datastruktur som är en kombination av ett binärt sökträd och en heap, därav namnet. Strukturen är ett binärt sökträd där varje nod innehåller data och har ett vänster samt ett högerbarn. Det vänstra delträdet till noden innehåller element som är lägre och det högra delträdet innehåller element som är högre. Noden tilldelas även slumpmässigt en prioritet som ska uppfylla heapordningen. Det innebär att på varje nivå måste föräldernoden ha samma eller högre prioritet än sina barn. Stämmer inte heapordningen så sker rotationer till dess att den gör, och trädet blir bättre balanserat. Det kommer fortfarande vara obalanserat men inte så farligt. Priotiteten gör alltså att trädet inte blir för obalanserat och det spelare då ingen roll vad inputen har för ordning.

Det som då sker vid implementation är är att ett element sätts in och jämförs först med rotnoden och fortsätter sedan nedåt och jämför noderna till dess att den hittar sin rätta plats. Den nya noden får en prioritet tilldelad av en random generator och om den har högre prioritet än noderna längre upp i trädet så roteras den upp för att återställa heapordningen. Trädets distribution blir därför slumpmässig vilket gör att det inte kommer bli en perfekt triangel med perfekt balans. Men det spelar inte så stor roll, och det gör att det blir enkelt att implementera eftersom det bara sker enkla fall där rotationen endast sker uppåt, vilket är en billig operation. 

Sökningen sker på samma sätt som hos binära sökträd. Det behöver alltså inte ta hänsyn till prioriteten. Först jämförs rotnoden och om värdet är mindre fortsätter sökningen ner till vänster och om värdet är högre så fortsätter det ner till höger. Sedan jämförs barnnoden, är det samma värde så avslutas sökningen, annars fortsätter sökningen på samma sätt och kollar om värdet är högre eller lägre. Detta sker till dess att vi hittar noden med det värde vi söker, finns inget sådant så returneras false.

Vid borttag av noder så ändras prioriteten hos noden som sätts till oändlighet vilket gör att noden kan roteras ner och bli till ett löv utan barnnoder. När noden roterats ner och blivit till ett löv kan det då tas bort. Om noden som ska tas bort redan är ett löv så kan det tas bort direkt. Genom att göra på detta sätt så ändras inte heapordningen och trädet förblir binärt. Treaps är enkla datastrukturer med en relativt enkel implementation och borttagning, som även har en passande tidkomplexitet. Detta gör att treaps kan vara att föredra framför andra binära sökträd.  

\section*{Röd-Svarta Träd}

Röd-svarta träd är självbalanserade binära sökträd där varje nod har en extra bit som representerar dennes färg, antingen svart eller röd. Ett röd-svart träd har vissa egenskaper som måste uppfyllas för att det inte ska bli för obalanserat. Varje nod i trädet måste vara antingen röd eller svart, en röd nod kan inte ha en röd förälder eller röda barn, varje väg från rotnoden till löven måste ha lika många svarta noder, och rotnoden måste vara svart. Dessa egenskaper tillsammans ser till att trädet är någorlunda balanserat. Om någon av dessa egenskaper inte uppfylls så måste något göras för att lösa problemet. Det kan hända vid insättning och borttag av noder att trädet blir obalanserat. I avl-träd används rotationer för att balansera upp trädet, vilket också används hos röd-svarta träd, men det finns en till teknik där noderna helt enkelt färgas om tills dess att egenskaperna uppfylls. Röd-svarta träd är enklare än avl-träd, men sämre balanserade. De kan ha dubbelt så många noder i en gren som den har i en annan om man konstruerar det på värsta möjliga sätt.

Sökningen i ett röd-svart träd sker på samma sätt som hos binära sökträd men vid insättning och borttag är det lite annorlunda då både omfärgning och rotationer används. En ny nod sätts in på samma sätt som hos binära sökträd och får färgen röd. Skulle den nya noden vara en rotnod så får den färgen svart. Om föräldern till den insatta noden är svart så behöves det inte göra något. Däremot, säg att vi sätter in ett värde som leder till att någon av egenskaperna inte uppfylls så försöker man först göra omfärgningar, då färjar vi helt enkelt om en nod, vilket går snabbt. Om omfärgning inte är möjligt så används rotationer. Vilken teknik som används beror på vad förälderns syskonnod har för färg. Är den röd så kan en omfärgning göras, är den svart görs rotation och/eller omfärgning. Målet är alltså att uppfylla de fyra egenskaperna som gör att trädet balanseras upp.

Vid insättning kollar man färgen på förälderns syskonnod för att bestämma vad som ska hända, men vid borttag håller man koll på vad syskonnoden har för färg. Vid insättning är egenskapen att två röda noder inte får vara efter varandra den som oftast inte uppfylls, men vid borttag är det egenskapen att varje väg från rotnoden till löven måste innehålla lika många svarta noder som kan brytas. Detta är eftersom vid borttag av en svart nod så kommer en väg få ett minskat antal svarta noder. Vid borttag i binära söktröd behöver vi endast ta hand om löv eller noder med endast ett barn, för om vi vill ta bort en nod med två barn så byter vi ut den mot en lövnod eller en nod med endast ett barn som då tas bort. Röd-svarta träd fungerar på samma sätt men man vill undvika användning av en nod med barn, eftersom det kan hända att två röda noder hamnar efter varandra i mitten av trädet. För att förhindra att bryta mot egenskaperna vill man därför se till att lövet som tas bort är rött vilket görs med Top-Down metoden. Den går alltså uppifrån och ner, och om den stöter på en nod med två röda barn så byter föräldern och barnnoderna färg. Skulle egenskaperna fortfarande inte uppfyllas så görs rotationer.



\end{document}
