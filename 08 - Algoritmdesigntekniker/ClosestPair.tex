% The format (A5) is selected to facilitate reading on small
% devices and should NOT be changed. 
\documentclass[a5paper,10pt,oneside]{article}

% The package babel is loaded for Swdish with Swedish hyphenation,
% replaces "Contents" with "Innehållsförteckning, "References"
% with "Litteraturförteckning", etc.
\usepackage[swedish]{babel}

\usepackage[T1]{fontenc}

% The package "inputenc" lets us specify what character encoding
% has been used to save the .tex file. If your computer runs
% Linux, the encoding is probably "utf8" by default, while under
% Windows the default will probably be "latin1" The wrong
% character encoding may give strange signs instead of "å", "ä"
% and "ö" or may result in compilation errors.

%\usepackage[latin1]{inputenc} % Probably right if you use Windows
\usepackage[utf8]{inputenc}  % Probably right if you use Linux

% The packages listed below are optional and can be removed if you
% don't use them 
\usepackage{graphicx} 
\usepackage{cite}
\usepackage{url}
\usepackage{ifthen}
\usepackage{listings}	

% These two lines set up options for the listings package and
% can be removed if you don't use it, or changed if you, e.g, 
% use another language than Java. 
% For more information about the listings package see:
% ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf

\usepackage{ifpdf}
\ifpdf
	\usepackage[hidelinks]{hyperref}
\else
	\usepackage{url}
\fi


% Change NR and TITLE below to appropriate values
\title{Tema NR: 8 Algoritmdesigntekniker}

% Write the name and user namn for all participants in the group here.
% Separate persons with \and
\author{Oscar Törnquist \url{osta3589} \and Emil Rosell \url{emro9957}}

\begin{document}

\maketitle

\section{class Closest Pair}
Algoritmen räknar räknar ut och returnerar den kortaste sträckan mellan två \textit{Point's}. Vi har valt att använa oss av javas java.awt.Point; då det uppfyller kravet vi haft på att lagra en X och en Y kordinat. Därefter har vi implementerat egna Comparators för att kunna jämföra Points med hjälp av X eller Y kordinater när dom ska sorteras i listan. Vi har valt att lagra alla punkter i en ArrayList då det går relativt fort att hämta punkter med hjälp av index samt sortera punkterna.

\subsection{void addPoint(Point p)}
Metoden tar för givet att användaren av algoritmen vet att det behövs läggas till punkter att jämföra emellan, vilket denna metod är till för. Den börjar med att kolla om självaste punkten som ska läggas till redan finns i listan och om den gör det så skrivs ett medellande ut i konsolen för att visa att det inte går att lägga till likadana punkter i listan. Anledningen är för att vi vill visa att algoritmen är funktionell och om det finns två punkter med samma värde får vi resultatet $0.0$ vilket är mer eller mindre ett riktigt tråkigt resultat.
Om punkten inte finns i listan så läggs den till i listan \textit{points}.

\subsection{double getDistance(Point a, Point b)} 
Denna metod returnerar avståndet mellan punkt $a$ och punkt $b$ med hjälp av pythagoras sats. 

\subsection{double findClosestPair(List<Point> list)} 
Då vi vill underlätta för testning så har vi skapat en metod som tar en lista som argument och kopierar denna lista till klassens ArrayList för att sedan räkna ut kortaste sträckan mellan två punkter. 
Metoden returnerar en Double.

\subsection{double findClosestPair()} 
Metoden börjar med att kontrollera ifall det finns något att använda sig av i ClosestPair algoritmen. Om listans storlek är mindre eller lika med 1 så returnerar metoden -1 då det inte finns några punkter att jämföra med. Annars så sorterar den listan efter X-värden för att sedan returnera värdet från den privata metoden \textit{findClosestPair(int start, int end)}.

\subsection{private double findClosestPair(int start, int end)} 
Hjärtat i hela klassen.
Då denna metod i huvudsak använder sig av \textit{Divide and Conquer}-tekniken så betyder det att den delar upp problemen, i det här fallet listan, rekursivt genom att dela upp och jämföra mindre delarna av listan.

Självaste metoden tar i två argument, en int som markerar startpunkten och en int som markerar slutpunkten. Om slutpunkten subtraherat med startpunkten blir mindre eller lika med två så kallar metoden på en algoritm som kontrollerar och returnerar den kortaste vägen mellan dom punkter som finns på de valda indexen. Då metoden i sig halverar listan varje gångn den kallas på så blir det mindre och mindre intervall att jobba med och därför har vi bas-algoritmen som finns när det inte går att halvera listan längre. Om listan går att halvera så räknar den ut vilket det mittersta indexet är samt X värdet som är hälften av första X värdet och sista för att senare räkna ut vilka punkter som ligger precis utanför """ halveringsgränsen""". Därefter kallas samma metod rekursivt med halveringsvärdena, en del till vänster som är från och med startvärden till och med mitten samt en del till höger som är från och med ett till höger om mittenvärdet, då mittenvärdet redan är använt, till och med slutvärdet.
Då har vi delat upp listan i två delar som via det rekursiva anropet delar upp varje del på häflten tills det är mindre eller lika med 2 element kvar som testas. Sen när listan är uppdelat i höger och vänster kontrolleras punkterna runtomkring för att se om det är nåt intill halveringsgränsen som är kortare än det hittills kortaste avståndet. Med hjälp av M. Weiss pseudokod på sidan 453 kan vi se om det finns några punkter nära som är kortare än det hittills kortaste resultatet.
Därefter returneras resultatet tills de rekursiva anropen är över.

\section{private double baseCase(int start, int end)} 
Denna metod används endast när det är mindre eller lika med 2 element kvar  och itererar över listan med hjälp av startvärdet och slutvärdet. Sen jämförs värdet på variabeln delta med ett nytt värde som kontrolleras ifall det är mindre än det gamla värdet. Om det stämmer så deklareras variabeln delta till det nya värdet och loopen fortsätter tills det når slutvärdet.
Därefter returneras värdet tillbaka till den rekursiva metoden.


\end{document}
